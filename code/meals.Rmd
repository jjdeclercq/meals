---
title: "meals"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# install.packages("googlesheets4")
require(googlesheets4)
require(stringr)
require(dplyr)
require(magrittr)
require(tidyverse)
require(DT)


source("/Users/joshvumc/Documents/GitHub/meals/code/meal_funs.R")

```

### TO DO LIST
  - Need to group foods in way that makes most sense
  - Need to address misspelling or variants of ingredients
  - Create equivalance matrix for ingredients ie cabbage = red cabbage
  - How to handle directionality ie dry chickpeas can sub for canned, but not the other way
  - easily determine which ingredients are needed to make recipe
  - pantry staples that are also recipes e.g. pickled onion
  - strip white space from ingredients
  
  
  - create a workable nomenclature
  - only parse new recipes and add to existing df
  - sort out peas and corn
  - better classification for pantry items
  - brackets around swappable and optional ingredients
  - in add recipes app, preselected options are an issue
  - cuisine is practically useless
  - type: main, meal, side, etc. could use some clean up as well
  
  Makeability is NOT ignoring optional ingredients
  
### Order
 - If new recipe is added to meals list
  - download meals
  - expand recipes
  - update ingredients list
      - If there are new ingredients, classify ingredients
      - If any of the new ingredients are makeable, need to input their recipe as well
  - generate list of makeable recipes
       
  # observeEvent(
  #   c(input$fr_submit),
  #   {
  #     not.selected <- makeable.rv$RRR$Recipe[1 - getReactableState("filter_recipes_df", "selected")]
  #     current.select <- makeable.rv$RRR$Recipe[getReactableState("filter_recipes_df", "selected")]
  #     makeable.rv$Selected <- c(setdiff(makeable.rv$Selected, not.selected), current.select)
  # 
  #   }, ignoreInit = TRUE)

```{r}
# Get df of recipes
meals <- read.csv("/Users/joshvumc/Documents/GitHub/meals/data/recipes_in.csv")
# meals.out <- read.csv("/Users/joshvumc/Documents/GitHub/meals/data/recipes_in.csv")

recipes_expand <- expand.recipes(meals)
# write.csv(recipes_expand, "/Users/joshvumc/Dropbox/meal_planning/recipes_expand.csv", row.names = FALSE)
save(recipes_expand, file= "/Users/joshvumc/Documents/GitHub/meals/data/recipes_expand.rda")
# load("/Users/joshvumc/Documents/GitHub/meals/data/recipes_expand.rda")
## current ingredient list

ingredients <- read.csv("/Users/joshvumc/Documents/GitHub/meals/data/ingredients.csv")

##### update ingredient list 

new.ingredients <- update_ingredients(recipes_expand, ingredients)
write.csv(new.ingredients, "/Users/joshvumc/Documents/GitHub/meals/data/ingredients.csv", row.names = FALSE)

## Make and colorize menu of makeable meals
made_menu <- make_menu(recipes_expand, new.ingredients, meals) 

  write.csv(made_menu, "/Users/joshvumc/Documents/GitHub/meals/data/recipes_out.csv")

  ## Need to make this code work to speed up program
  # make_menu(expand.recipes(meals[1,]), ingredients, meals)
  
# new.ingredients %>% filter(grepl("rice", name))
# which(made_menu$Selected==1)
```

```{r}
lg <- c(30, 16)
md <- c(23, 12)
sm <- c(14, 8)

pizza.cost <- function(x){
  x[1]/((x[2]/2)^2*pi)
}
pizza.cost(sm)
pizza.cost(md)
pizza.cost(lg)
# recipes_expand <- bind_rows(meals %>% filter(Meal %in% setdiff(meals$Meal, recipes_expand$recipe %>% unique())) %>% expand.recipes(),
#           recipes_expand)

# bind_rows(expand.recipes(meals[1,]),
#           expand.recipes(meals[45,]),
#           expand.recipes(meals[133,])) %>%
#   mutate(across(is.numeric, ~replace_na(.x, 0)))

# load("/Users/joshvumc/Dropbox/meal_planning/DATA/recipes_expand.rda")
# recipes_expand <- read.csv( "/Users/joshvumc/Dropbox/meal_planning/recipes_expand.csv")
# new_row <- meals[1,]
# expanded_new <- expand.recipes(new_row)
# #             load("/Users/joshvumc/Dropbox/meal_planning/recipes_expand.rda")
#             recipes_expand_new <- bind_rows(expanded_new, recipes_expand) %>%
#                  mutate(across(is.numeric, ~replace_na(.x, 0)))
# # #             save(recipes_expand, file= "/Users/joshvumc/Dropbox/meal_planning/recipes_expand.rda")
#             
#             l.ingredients <- read.csv("/Users/joshvumc/Dropbox/meal_planning/shinyapp/react/ingredients.csv")
#             made_menu <- make_menu(recipes_expand, l.ingredients)
#             write.csv(made_menu, "/Users/joshvumc/Dropbox/meal_planning/jd_recipes.csv")
#             
#             new.ingredients <- update_ingredients(recipes_expand, l.ingredients)
#             write.csv(new.ingredients, "/Users/joshvumc/Dropbox/meal_planning/shinyapp/react/ingredients.csv", row.names = FALSE)
          # make_menu(recipes_expand_new, new.ingredients, meals)  
   setdiff(c("a", "b", "c", "d"), "b")
   
   mf
   expand.recipes(meals %>% filter(grepl("szechuan style blistered", Recipe)))
   
   m <- meals %>% filter(grepl("szechuan style blistered", Recipe))
   g <- meals %>% filter(grepl("popcorn granola bars", Recipe))
   
   m %<>% mutate(Ingredients = gsub("[()]|\\[|\\]", "", Ingredients))
  ing <- str_split(m$Ingredients, ", ") 
  names(ing) <- m$Recipe
  
  g %<>% mutate(Ingredients = gsub("[()]|\\[|\\]", "", Ingredients))
  ingg <- str_split(g$Ingredients, ", ") 
  names(ingg) <- g$Recipe
  
  mf(m, ing = ing)
  
   expand.grid(c(str_split(grep(" or ", ingg[[1]], v = TRUE, inv = F), " or "),
                item = list(grep(" or ", ingg[[1]], v = TRUE, inv = TRUE))))
   
   meals %>% filter(grepl("japanese side salad with carrot and ginger dressing", Recipe)) %>% 
     separate(., Ingredients, c("Ingredients", "Optional"), sep= "\\[")
   
   
   gg <- str_split("a, b, c, d or e, f or , g or ", ", ")
   
    expand.grid(c(str_split(grep(" or ", gg[[1]], v = TRUE, inv = F), " or "),
                item = list(grep(" or ", gg[[1]], v = TRUE, inv = TRUE))))%>% 
    mutate(v =1, Recipe = "names(ing)[x]", VarXX = " ")%>%  unite(.,"variant", contains("Var"), remove = FALSE, sep = " ") %>% select(-VarXX)%>%
    pivot_longer(., c(-v, -Recipe,-variant)) %>% unique() %>% select(-name) %>% mutate(value = str_trim(value, "both"))%>%
    filter(value != "") %>% 
    pivot_wider(., names_from = "value", values_from = "v")
    
    
    meals %>% separate(., Ingredients, c("Ingredients", "Optional"), sep= "\\[") %>%
      mutate(Optional = gsub("\\]", " or ", Optional), Optional = gsub(",", " or", Optional)) %>%
      unite(., "Ingredients", c(Ingredients, Optional), remove = TRUE, na.rm = TRUE, sep = "")
    
    ## Trying to work through the makeability mess
    
    # meals %>% separate(., Ingredients, c("Ingredients", "Optional"), sep= "\\[") %>%
    #   mutate(Optional = gsub(",", " or", Optional), 
    #          Optional = ifelse(!is.na(Optional), paste0("[", Optional), NA) )%>%
    #   unite(., "Ingredients", c(Ingredients, Optional), remove = TRUE, na.rm = TRUE, sep = "") %>%
    #   write.csv(., "/Users/joshvumc/Documents/GitHub/meals/data/recipes_in.csv", row.names = FALSE)
    
MM <-  meals %>% separate(., Ingredients, c("Ingredients", "Optional"), sep= "\\[")# %>%
      # mutate(Optional = gsub(" or ", " or , ", Optional), Optional = gsub("\\]", " or ", Optional)) %>%
      # unite(., "Ingredients", c(Ingredients, Optional), remove = TRUE, na.rm = TRUE, sep = "") 

NN <- expand.recipes(MM)

OO <-make_menu(NN, new.ingredients, meals) 

OO %>% filter(grepl("japanese side salad with carrot and ginger dressing", Recipe))

# 3594

NN <- expand.recipes(MM%>% filter(grepl("popcorn granola bars", Recipe)))

OO <-make_menu(NN, new.ingredients, meals%>% filter(grepl("popcorn granola bars", Recipe))) 

setdiff("a", NULL)
```

```{r}
## Expand recipes not working? Need to error check that food not entered twice...

meals %<>% mutate(Ingredients = gsub("[()]|\\[|\\]", "", Ingredients))
  ing <- str_split(meals$Ingredients, ", ") 
  names(ing) <- meals$Meal
  
cx <-  bind_rows(lapply(as.list(1:length(ing)), FUN = function(x) mf(x, ing = ing))) 
  
cx  %>%
    mutate(across(where(is.numeric), .fns = ~replace_na(.x, 0)))
  


  expand.grid(c(str_split(grep(" or ", ing[[298]], v = TRUE, inv = F), " or "),
                item = list(grep(" or ", ing[[298]], v = TRUE, inv = TRUE)))) %>% 
    mutate(v =1, recipe = names(ing)[298], VarXX = " ")%>%  unite(.,"variant", contains("Var"), remove = FALSE, sep = " ") %>% select(-VarXX)%>%
    pivot_longer(., c(-v, -recipe,-variant)) %>% unique() %>% select(-name) %>%mutate(value = str_trim(value, "both"))%>%
    filter(value != "") %>% 
    pivot_wider(., names_from = "value", values_from = "v")

```

Need to:
 Add actions to update selections
 Create way to store saved selections and make sure they persist between sessions
 create new tab panel to show selected 

 

```{r}
### Grocery planning


recipes_expand 
ingredients
meals$Meal[c(5,7,8)]

recipes_expand %>% filter(recipe %in% meals$Meal[c(5,7,8:12)]) %>% select(-variant) %>% pivot_longer(., -recipe) %>% filter(value ==1) %>%
  group_by(name) %>%tally()

wok <- made_menu %>% filter(Source == "Wok") %$% Recipe

recipes_expand %>% filter(Recipe %in% wok[19:28])  %>% 
  select(-variant) %>% group_by(Recipe) %>% summarise_all(mean) %>% pivot_longer(., -Recipe) %>% filter(value >0) %>%
  group_by(name) %>%summarise(n = sum(value), count = n()) %>%
  left_join(., ingredients %>% select(name, has, class), by = "name") %>% arrange(class,  desc(n)) %>%
  mutate(name = fct_inorder(name)) %>%
  ggplot(., aes(x = name, y = n, fill = factor(has))) + geom_bar(stat = "identity") +
  facet_grid(~class, scales = "free", space = "free")+ theme_bw()+
  guides(fill = FALSE) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(x= NULL, y = NULL) +
  scale_fill_manual(values = c("#CD2626","#458B00")) 

e# f.exchange("a or b or 3 or c or d")

made_menu %>% filter(Recipe %in% wok[1:5]) 
```

```{r}
# wordcloud
require(wordcloud)
wci <- ingredients%>% filter(class == "spice") %>% mutate(word = name, freq = n) %>% mutate(color = ifelse(has==1, "green", "red")) %>%
  arrange(n) #%>% filter(n > 0)


wordcloud(wci$name, freq = wci$n, rot.per = 0, colors = as.character(wci$color), min.freq = 0, ordered.colors = TRUE)

wordcloud2(wci, color =as.character(wci$color) )

# Maybe don't do wordcloud--df is better?

ingredients %>% group_by(class, class2) %>% summarise(Ingredients = toString(name))%>%
     mutate(Ingredients = sprintj6(all_of(has), Ingredients, "#458B00"))%>%
    mutate(Ingredients = sprintj6(all_of(not.has), Ingredients, "#CD2626")) %>%
  mutate(Ingredients = gsub("xyz", " or ", gsub("><",">, <",gsub("&","", Ingredients)))) %>%
    reactable(., columns = list(Ingredients = colDef(html = TRUE, width = 660)),
          theme = reactableTheme(rowSelectedStyle = list(backgroundColor = "#eee", boxShadow = "inset 2px 0 0 0 #ffa62d")))
```




```{r}
## Work towards reformatting the ingredients as Required (), one of(), optional ()
## Attempt 1
meals[1:6,] %>% separate_rows(., "Ingredients", sep = ",") %>% 
  mutate(X = case_when(grepl(" or $", Ingredients) ~ "Optional",
                       grepl(" or ", Ingredients) ~ "One of",
                       TRUE ~ "Essential")) %>%
  mutate(Ingredients =   case_when(X == "Essential" ~ Ingredients,
                                   X == "Optional" ~ paste0("[", gsub(" or ", ", ", gsub(" or $", "", Ingredients)), "]"),
                                   X== "One of" ~ paste0( "(", str_trim(Ingredients), ")"))) %>%
  arrange(Meal, X) %>%
  group_by(Meal, Source, Page, Cuisine, Type) %>% summarise(Ingredients = toString(Ingredients))

## Attempt 2 -- works, but needs to be done every time recipes_out is made  

sprintj7 <- function(vec, V, color){
  # V <- gsub(" or | or$", "&xyz&", gsub(" or&", "&xyz& &", gsub("& | &","&", paste0("&",gsub(",","&&",V), "&"))))
  len <- length(vec)
  for(i in 1:length(vec)){
    V <- gsub(paste0("&",vec[i],"&"), sprintf("<span style='color: %s;'>%s</span>", color, vec[i]), V)
  }
  V
}
  meals[7:10,] %>% 
    mutate(Ingredients = gsub(" or | or$", "&xyz&", gsub(" or&", "&xyz& &", gsub("& | &","&", paste0("&",gsub(",","&,&",Ingredients), "&"))))) %>% 
    separate_rows(., "Ingredients", sep = ",")%>% 
  mutate(X = case_when(grepl("&xyz& &$", Ingredients) ~ "Optional",
                       grepl("&xyz&", Ingredients) ~ "One of",
                       TRUE ~ "Essential"))%>%
  mutate(Ingredients =   case_when(X == "Essential" ~ Ingredients,
                                   X == "Optional" ~ paste0("[", gsub(" or ", ", ", gsub("&xyz& &$", "&", Ingredients)), "]"),
                                   X== "One of" ~ paste0( "(", str_trim(Ingredients), ")"))) %>%
  arrange(Meal, X) %>%
  group_by(Meal, Source, Page, Cuisine, Type) %>% 
    summarise(Ingredients = toString(Ingredients)) %>%
     mutate(Ingredients = sprintj7(all_of(has), Ingredients, "#458B00"))%>%
    mutate(Ingredients = sprintj7(all_of(nh), Ingredients, "#CD2626"))%>%
    mutate(Ingredients = sprintj7(all_of(subs1), Ingredients, "#CDAD00"))%>%
    mutate(Ingredients = sprintj7(all_of(subs2), Ingredients, "orange"))%>%
  mutate(Ingredients = sprintj7(all_of(make4), Ingredients, "#1C86EE"))%>% 
    mutate(Ingredients = gsub("xyz", " or ", gsub("><",">, <",gsub("&","", Ingredients)))) %>%
    reactable(., columns = list(Ingredients = colDef(html = TRUE)),
          theme = reactableTheme(rowSelectedStyle = list(backgroundColor = "#eee", boxShadow = "inset 2px 0 0 0 #ffa62d")))


## Attempt 3 - make it work without & and xyz's
## This works!?


meals[1:6,] %>% separate_rows(., "Ingredients", sep = ",") %>% 
  mutate(X = case_when(grepl(" or $", Ingredients) ~ "Optional",
                       grepl(" or ", Ingredients) ~ "One of",
                       TRUE ~ "Essential")) %>%
  mutate(Ingredients =   case_when(X == "Essential" ~ Ingredients,
                                   X == "Optional" ~ paste0("[", str_trim(gsub(" or ", ", ", gsub(" or $", "", Ingredients))), "]"),
                                   X== "One of" ~ paste0( "(", str_trim(Ingredients), ")"))) %>%
  arrange(Meal, X) %>%
  group_by(Meal, Source, Page, Cuisine, Type) %>% summarise(Ingredients = toString(Ingredients))%>% 

    mutate(Ingredients = gsub(" or ", "&xyz&",  gsub("& | &|&  ","&", paste0("&",gsub(",","&,&",Ingredients), "&"))) )%>%
  mutate(Ingredients = gsub("&(", "&(&", Ingredients, fixed = TRUE)) %>%
  mutate(Ingredients = gsub(")&", "&)&", Ingredients, fixed = TRUE)) %>%
  mutate(Ingredients = gsub("&[", "&[&", Ingredients, fixed = TRUE)) %>%
  mutate(Ingredients = gsub("]&", "&]&", Ingredients, fixed = TRUE)) %>%
     mutate(Ingredients = sprintj7(all_of(has), Ingredients, "#458B00"))%>%
    mutate(Ingredients = sprintj7(all_of(nh), Ingredients, "#CD2626"))%>%
    mutate(Ingredients = sprintj7(all_of(subs1), Ingredients, "#CDAD00"))%>%
    mutate(Ingredients = sprintj7(all_of(subs2), Ingredients, "orange"))%>%
  mutate(Ingredients = sprintj7(all_of(make4), Ingredients, "#1C86EE"))%>% 
    mutate(Ingredients = gsub("xyz", " or ", gsub("><",">, <",gsub(",", ", ", gsub("&","", Ingredients))))) %>%
    reactable(., columns = list(Ingredients = colDef(html = TRUE)),
          theme = reactableTheme(rowSelectedStyle = list(backgroundColor = "#eee", boxShadow = "inset 2px 0 0 0 #ffa62d")))


## update all recipes

meals %>% #filter(Meal == "30 minute black bean soup") %>%
  separate_rows(., "Ingredients", sep = ",") %>% 
  mutate(X = case_when(grepl(" or $", Ingredients) ~ "Optional",
                       grepl(" or ", Ingredients) ~ "One of",
                       TRUE ~ "Essential")) %>%
    arrange(Meal, X) %>%
  group_by(Meal, Source, Page, Cuisine, Type, X) %>% summarise(Ingredients = toString(Ingredients)) %>%
  mutate(Ingredients =   case_when(X == "Essential" ~ Ingredients,
                                   X == "Optional" ~ paste0("[", gsub(", ,", ",", str_trim(gsub(" or ", ", ", gsub(" or $", "", Ingredients)))), "]"),
                                   X== "One of" ~ paste0( "(", str_trim(Ingredients), ")"))) %>%
  group_by(Meal, Source, Page, Cuisine, Type) %>% summarise(Ingredients = toString(Ingredients)) %>%
  mutate(Cuisine = ifelse(Cuisine == "", "western", Cuisine)) #%>%
  #write.csv(., "/Users/joshvumc/Documents/GitHub/meals/data/recipes_in.csv", row.names = FALSE)




## Need to update recipe entry as well
fop <- "a or b or c"
fop <- NULL
fex <- NULL
fex <- "d or e or 4 or f or g"
fin <- "h, i, j, k"

# f.optional <- function(vec) {ifelse(length(vec)==0, "", paste0(str_c(vec, collapse = " or "), " or , "))}
# f.exchange <- function(vec) {ifelse(length(vec)==0, "", gsub(" or [0-9]+ or", ",", paste0(str_c(vec, collapse = " or "), ", ")))}
# f.include <- function(vec) {str_c(vec, collapse = ", ")}
# paste.ingredients <- function(opt, exc, inc) paste0(f.optional(opt),f.exchange(exc), f.include(inc), collapse = "")
# 
# paste.ingredients(fop, fop, fin)

f.optional2 <- function(vec) {ifelse(length(vec)==0, "", paste0("[", str_c(vec, collapse = " or "), "]"))}
f.exchange2 <- function(vec) {ifelse(length(vec)==0, "", paste0("(",gsub(" or [0-9]+ or", ",", paste0(str_c(vec, collapse = " or "), ")"))))}
f.include2 <- function(vec) {str_c(c(vec), collapse = ", ")}
# paste.ingredients2 <- function(opt, exc, inc) paste(f.include2(inc),f.exchange2(exc),f.optional2(opt), collapse = ",")

paste.ingredients2 <- function(opt, exc, inc){
data.frame(ing = c(f.include2(inc), f.exchange2(exc), f.optional2(opt) ), 
           type = c("in", "ex", "op")) %>% 
  filter(ing != "") %$% toString(ing)
}

paste.ingredients2(fop, fex, fin)

## I think I'm ready to update app
 # add brackets to existing meals -- can only be in recipe output because of expand recipes!
# add new paste.ing code-- can only be in recipe output because of expand recipes!
# update recipes out code with with regex.ing
# pray

# separate_rows(., "Ingredients", sep = ",") %>% 
#     mutate(X = case_when(grepl(" or $", Ingredients) ~ "Optional",
#                          grepl(" or ", Ingredients) ~ "One of",
#                          TRUE ~ "Essential")) %>%
#     mutate(Ingredients =   case_when(X == "Essential" ~ Ingredients,
#                                      X == "Optional" ~ paste0("[", str_trim(gsub(" or ", ", ", gsub(" or $", "", Ingredients))), "]"),
#                                      X== "One of" ~ paste0( "(", str_trim(Ingredients), ")"))) %>%
#     arrange(Meal, X) %>%
#     group_by(Meal, Source, Page, Cuisine, Type) %>% summarise(Ingredients = toString(Ingredients))%>%
#     regex.ingredients(.) %>%

tind <- data.frame(Meal = "test", Ingredients = paste.ingredients2(fop, fex, fin))
ting <- str_split(tind$Ingredients, ", ") 
  names(ting) <- tind$Meal
  mf(1, ting)
expand.grid(c(str_split(grep(" or ", ting[[1]], v = TRUE, inv = F), " or "),
                item = list(grep(" or ", ting[[1]], v = TRUE, inv = TRUE))))%>% 
    mutate(v =1, recipe = names(ting)[1], VarXX = " ")%>%  unite(.,"variant", contains("Var"), remove = FALSE, sep = " ") %>% select(-VarXX)%>%
    pivot_longer(., c(-v, -recipe,-variant)) %>% unique() %>% select(-name) %>%filter(value != "") %>%
  mutate(value = gsub("[()]|\\[|\\]", "", value)) %>%
    mutate(value = str_trim(value, "both"))%>%
    pivot_wider(., names_from = "value", values_from = "v")

# can add this to expand recipes, so don't have to bracketize everything everytime menu is colorized
expand.recipes(tind %>% mutate(Ingredients = gsub("[()]|\\[|\\]", "", Ingredients)))
  
```



```{r}
recipes_expand <- expand.recipes(meals%>% filter(grepl("popcorn granola bars", Recipe)))
meals <- meals %>% filter(grepl("popcorn granola bars", Recipe))

## This is the make_meal function outside of the function
has <- ingredients %>% filter(has == 1) %$% name
not.has <- ingredients %>% filter(has == 0) %$% name
not.has <- not.has[not.has %in% ingredients$name]

vegan <- ingredients %>% filter(vegan==1) %$% name
veg <- ingredients %>% filter(vegetarian==1) %$% name

equi <- ingredients %>% select(name, equal) %>%
   separate_rows(., equal, sep = ", ") %>%
  left_join(., ingredients %>% select(equal = name, has2 = has), by = "equal") %>% 
  filter(has2==1) %$% name %>% unique()
equi <- c(has, equi)%>% unique()

sometimes <- ingredients %>% select(name, sometimes) %>%
   separate_rows(., sometimes, sep = ", ") %>%
  left_join(., ingredients %>% select(sometimes = name, has2 = has), by = "sometimes") %>% 
  filter(has2==1) %$% name %>% unique()
sometimes <- c(sometimes, equi) %>% unique()

### Things I don't have, but I can substitute for
subs1 <- ingredients %>% select(name,has, equal) %>%
   separate_rows(., equal, sep = ", ") %>%
  left_join(., ingredients %>% select(equal = name, has2 = has), by = "equal") %>% 
  filter(has2==1, has==0) %$% name %>% unique()

subs2 <- ingredients %>% select(name,has, sometimes) %>%
   separate_rows(., sometimes, sep = ", ") %>%
  left_join(., ingredients %>% select(sometimes = name, has2 = has), by = "sometimes") %>% 
  filter(has2==1, has==0) %$% name %>% unique() %>% setdiff(., subs1)

nh <- setdiff(not.has, c(subs1, subs2))


has <- sort.vec(has)
nh <- sort.vec(nh)
subs1 <- sort.vec(subs1)
subs2 <- sort.vec(subs2)



MEAL <- recipes_expand %>% 
  rowwise() %>%
  mutate(n.ingredients = sum(c_across(where(is.numeric))))  %>% 
  mutate(p.ingredients = sum(c_across(any_of(has))), can.make = 1*(p.ingredients == n.ingredients),
         sub1 = sum(c_across(any_of(equi))), can.make2 = max(sub1 == n.ingredients, can.make), ## This can probably be reworked with the new subs1 variable
         sub2 = sum(c_across(any_of(sometimes))), can.make3 = max(sub2 == n.ingredients, can.make2), 
         n.vegan = sum(c_across(any_of(vegan))), is.vegan = n.vegan == n.ingredients, 
         n.veg = sum(c_across(any_of(veg))), is.veg = n.veg == n.ingredients) %>%
  group_by(Recipe, variant)%>% 
  mutate(makeability = 5 - (1+sum(c_across(contains("can.make")))),
         makeability = ifelse(makeability==4, 5, makeability))

make4 <- ingredients%>% filter(makeable ==1) %>% select(name, has) %>%
  left_join(., 
            MEAL%>%ungroup() %>% select(name = Recipe, makeability) %>% group_by(name) %>% summarise(makeability = min(makeability)),
            by = "name") %>% 
  filter(makeability %in% 1:3, has == 0) %$% name
reaching <- c(sometimes, make4) %>% unique()
make4 <- setdiff(make4, c(subs1, subs2))
nh <- setdiff(nh, make4)


MEAL <- MEAL %>% mutate(sub4 = sum(c_across(any_of(reaching))), can.make4 = 1*(sub4 == n.ingredients),
                makeability = ifelse(makeability==5 & can.make4==1, 4, makeability)) %>%
  group_by(Recipe) %>%
  mutate(variants = n(), make1 = sum(makeability==1), make2 = sum(makeability==2), make3 = sum(makeability==3)) %>%
  select(1, contains("make"), everything()) %>% 
  arrange(Recipe, makeability, desc(n.ingredients)) %>%
  select(Recipe, variant,makeability, n.ingredients, contains("can.make"), n.vegan, is.vegan, n.veg, is.veg, everything())%>% 
  dplyr::slice(1) %>%
  left_join(meals, ., by = "Recipe")


MEAL %>% regex.ingredients() %>%
  mutate(Ingredients = sprintj8(all_of(has), Ingredients, "#458B00"))%>%
    mutate(Ingredients = sprintj8(all_of(nh), Ingredients, "#CD2626"))%>%
    mutate(Ingredients = sprintj8(all_of(subs1), Ingredients, "#CDAD00"))%>%
    mutate(Ingredients = sprintj8(all_of(subs2), Ingredients, "orange"))%>%
    mutate(Ingredients = sprintj8(make4, Ingredients, "#1C86EE"))%>%
    mutate(Ingredients = gsub("xyz", " or ", gsub("><",">, <",gsub("&","", Ingredients))) )%>%
  group_by(Recipe) %>%
  mutate(diet = case_when(is.vegan ~ "Vegan",
                          is.veg & !is.vegan ~ "Vegetarian",
                          TRUE ~ "Non-vegetarian"),
         Needed = n.ingredients - p.ingredients) %>% 
  select(Recipe,  Source, Page,Type, Cuisine,diet, Ingredients, makeability, Needed) #%>%
  # write.csv(., "jd_recipes.csv")

## old colors
#BFE8CF, salmon, gold, orange, lightblue

# MEAL %>% select(contains("make")) %>% filter(makeability ==2)

c(has, subs1) %in% equi
```



```{r}
## Putting parens around exchangeable and optional ingredients

## 
  f.exchange(meals$Ingredients[5])  
  ## 16
split <- str_split(gsub(" or | or$", "&exchangeable&", gsub(" or&", "&optional& &", gsub("& | &","&", paste0("&",gsub(",","&&",meals$Ingredients[16]), "&")))), "&&") %>% unlist()
  
opt <- gsub("optional|&|","", grep("optional", split, v = TRUE)) %>% gsub("exchangeable", ", ",.) %>% paste0("[",., "]") %>% 
  toString() %>% ifelse(.=="[]", "", .)

exc <- grep("optional", split, v = TRUE, invert = TRUE) %>% grep("exchangeable", ., v = TRUE) %>% gsub("exchangeable"," or ", .) %>% gsub("&", "", .) %>% paste0("(",., ")") %>% toString() %>% ifelse(.=="()", "", .)

inc <- grep("optional|exchangeable", split, v = TRUE, invert = TRUE) %>% gsub("&", "", .)%>% toString()

ing.string <- paste(inc, exc, opt, sep = ", ")

has.vec <- ingredients %>% filter(has == 1) %$% name
  

sprintj6(has.vec, ing.string, "green")

rm(split)
```


```{r}
# reactable recipe table
rr <- read.csv("jd_recipes.csv") %>% select(-1)

reactable(rr[35:40,], columns = list(Ingredients = colDef(html = TRUE)),
          theme = reactableTheme(rowSelectedStyle = list(backgroundColor = "#eee", boxShadow = "inset 2px 0 0 0 #ffa62d")))
c("#458B00", "#CD2626", "#CDAD00", "#1C86EE")
```


```{r}
# play with reactable ingredients
require(reactable)

ingredients
reactable(ingredients %>% select(1:5), filterable = TRUE, minRows = 10, groupBy = c("class", "class2"), highlight = TRUE, compact = TRUE, onClick = "select", selection = "multiple", defaultSelected = which(ingredients$has ==1),
  theme = reactableTheme(rowSelectedStyle = list(backgroundColor = "#eee", boxShadow = "inset 2px 0 0 0 #ffa62d")))

which(ingredients$has ==1)
```

```{r}
## Play with restrictions
DF <- expand.recipes(meals)
ING <- ingredients %>% filter(!is.na(n))
MEALS <- meals

make_menu <- function(DF, ING, MEALS){

  ## vectors of ingredients both in and out of stock
  has <- ING %>% filter(has == 1) %$% name
  not.has <- ING %>% filter(has == 0) %$% name 
  not.has <- not.has[not.has %in% ING$name] ## not sure what this is doing -- glossing over entry errors?
  
    ## vectors of dietary restrictions
  vegan <- ING %>% filter(vegan==1) %$% name 
  veg <- ING %>% filter(vegetarian==1) %$% name
  not.restricted <- ING %>% filter(restricted == 0) %$% name
  
  ## vector of ingredients that are in stock that are equivalent substitutions for other ingredients
  equi <- ING %>% select(name, equal) %>%
    separate_rows(., equal, sep = ", ") %>%
    left_join(., ING %>% select(equal = name, has2 = has), by = "equal") %>% 
    filter(has2==1) %$% name %>% unique()
  equi <- c(has, equi)%>% unique()
  
  ## vector of ingredients that are in stock that can sometimes be substituted for other ingredients
  sometimes <- ING %>% select(name, sometimes) %>%
    separate_rows(., sometimes, sep = ", ") %>%
    left_join(., ING %>% select(sometimes = name, has2 = has), by = "sometimes") %>% 
    filter(has2==1) %$% name %>% unique()
  sometimes <- c(sometimes, equi) %>% unique()
  
  ### Things I don't have, but I can substitute for
  subs1 <- ING %>% select(name,has, equal) %>%
    separate_rows(., equal, sep = ", ") %>%
    left_join(., ING %>% select(equal = name, has2 = has), by = "equal") %>% 
    filter(has2==1, has==0) %$% name %>% unique()
  
  ## Things not in stock that there can sometimes be substituted for
  subs2 <- ING %>% select(name,has, sometimes) %>%
    separate_rows(., sometimes, sep = ", ") %>%
    left_join(., ING %>% select(sometimes = name, has2 = has), by = "sometimes") %>% 
    filter(has2==1, has==0) %$% name %>% unique() %>% setdiff(., subs1)
  
  ## List of ingredients that are not in stock or cannot be substitued for
  nh <- setdiff(not.has, c(subs1, subs2))
  
  ## Sort ingredient vectors by length
  has <- sort.vec(has)
  nh <- sort.vec(nh)
  subs1 <- sort.vec(subs1)
  subs2 <- sort.vec(subs2)
  
  
MEAL <- DF %>% 
    rowwise() %>%
    mutate(n.ingredients = sum(c_across(where(is.numeric))), ## Number of ingredients in recipe variant
           p.ingredients = sum(c_across(any_of(has))), ## Number of ingredients in stock for recipe variant
           can.make = 1*(p.ingredients == n.ingredients), ## If n and p match, then the recipe is makeable
           e.ingredients = sum(c_across(any_of(equi))), ## Number of ingredients or equivalent substitutions in stock for recipe variant
           can.make2 = max(e.ingredients == n.ingredients, can.make), ## If n and e match, then the recipe is makeable
           s.ingredients = sum(c_across(any_of(sometimes))), ## Number of ingredients or sometimes substitutions in stock for recipe variant
           can.make3 = max(s.ingredients == n.ingredients, can.make2), ## If n and s match, then the recipe is makeable
           n.vegan = sum(c_across(any_of(vegan))), ## Number of vegan ingredients
           is.vegan = n.vegan == n.ingredients, ## Determine if recipe is vegan
           n.veg = sum(c_across(any_of(veg))), ## Number of vegetarian ingredients
           is.veg = n.veg == n.ingredients, ## Determine if recipe is vegetarian
           n.restrict = sum(c_across(any_of(not.restricted))), ## Number of not restricted ingredients
           is.restrict = n.restrict == n.ingredients ## Determine if recipe is not restricted
           ) %>% 
    group_by(recipe, variant)%>% # determine makability
    mutate(makeability = 5 - (1+sum(c_across(contains("can.make")))), 
           makeability = ifelse(makeability==4, 5, makeability))%>% 
    mutate(makeability = replace_na(makeability, 995))

## Makeability
# 1 = makeable with no substitutions
# 2 = makeabile with equivalent ingredients
# 3 = makeabile with substitutable ingredients
# 4 = makeable after making intermediate ingredients
# 5 = not makeable

## some ingredients are themselves recipes
## This subsets those ingredients and cross references it with the makability rating 
## make4 is the list of ingredients not in stock but can be made in one shape or form
  make4 <- ING %>% filter(makeable ==1) %>% 
    select(name, has) %>%
    left_join(., 
              MEAL%>%ungroup() %>% select(name = recipe, makeability) %>% 
                group_by(name) %>% summarise(makeability = min(makeability, na.rm = TRUE)),
              by = "name") %>% 
    filter(makeability %in% 1:3, has == 0) %$% name
  
  ## 'reaching' is the vector of ingredient that are in stock + equivalent + substitutible or makeable ingredients 
  reaching <- c(sometimes, make4) %>% unique()
  
  ## limit make4 to the lowest level of availability
  make4 <- setdiff(make4, c(subs1, subs2))
  
  ## update vector of ingredients that are not available
  nh <- setdiff(nh, make4)

  ## fill in makeability 4 designation
  ## Determine if any of the recipe variants meet dietary restrictions AND equal to the best makeability rating
  ## Arrange data and pick the most makeabile variant with the most ingredients
  ## Add back the orginal ingredients list
  MEAL.slice <- MEAL %>% 
    mutate(m.ingredients = sum(c_across(any_of(reaching))), 
           can.make4 = 1*(m.ingredients == n.ingredients),
           makeability = ifelse(makeability==5 & can.make4==1, 4, makeability)) %>%
    select(1, contains("make"), everything()) %>% 
    arrange(recipe, makeability, desc(n.ingredients))%>%
    mutate(makeable.restrict = is.restrict == TRUE & makeability == min(makeability),
           makeable.vegan = is.vegan == TRUE & makeability == min(makeability),
           makeable.veg = is.veg == TRUE & makeability == min(makeability)) %>%
    select(Meal = recipe, variant,makeability, n.ingredients, contains("make"), n.vegan, is.vegan, n.veg, is.veg, everything())%>% 
    group_by(Meal) %>%
    dplyr::slice(1) %>%
    mutate(diet = case_when(is.vegan ~ "Vegan",
                            is.veg & !is.vegan ~ "Vegetarian",
                            TRUE ~ "Non-vegetarian"),
           restricted = makeable.restrict,
           Needed = n.ingredients - p.ingredients) %>%
    left_join(MEALS , ., by = "Meal") 
  
  ## Colorize ingredients based on what level of 'in stock' they are
    MEAL.slice %>%
      select(recipe = Meal,  Source, Page,Type, Cuisine,diet,restricted, Ingredients, makeability, Needed) %>%
     separate_rows(., "Ingredients", sep = ",") %>% 
  mutate(X = case_when(grepl(" or $", Ingredients) ~ "Optional",
                       grepl(" or ", Ingredients) ~ "One of",
                       TRUE ~ "Essential")) %>%
  mutate(Ingredients =   case_when(X == "Essential" ~ Ingredients,
                                   X == "Optional" ~ paste0("[", str_trim(gsub(" or ", ", ", gsub(" or $", "", Ingredients))), "]"),
                                   X== "One of" ~ paste0( "(", str_trim(Ingredients), ")"))) %>%
  group_by(recipe, Source, Page, Cuisine, diet, Type, restricted, makeability, Needed) %>% arrange(X) %>% 
      summarise(Ingredients = toString(Ingredients), .groups = "drop")%>%
      regex.ingredients() %>%
    mutate(Ingredients = sprintj7(all_of(has), Ingredients, "#458B00"))%>%
    mutate(Ingredients = sprintj7(all_of(nh), Ingredients, "#CD2626"))%>%
    mutate(Ingredients = sprintj7(all_of(subs1), Ingredients, "#CDAD00"))%>%
    mutate(Ingredients = sprintj7(all_of(subs2), Ingredients, "orange"))%>%
    mutate(Ingredients = sprintj7(all_of(make4), Ingredients, "#1C86EE"))%>%
    mutate(Ingredients = gsub("xyz", " or ", gsub("><",">, <",gsub(",", ", ", gsub("&","", Ingredients)))))
  
}  
 
### HERE 
    ## move this to meal_funs
## Need to add "restricted" button to app and logic that filters accoring to that selection
  
    
    
    
  # diet.restriction <- "Restricted"
  #     mutate(diet = case_when(diet.restriction == "Vegan" ~ 1*is.vegan,
  #                           diet.restriction == "Vegetarian" ~ 1*is.veg,
  #                           diet.restriction == "Restricted" ~ 1*is.restrict,
  #                           diet.restriction == "None" ~ 1)) %>%
  
# diet = case_when(makeable.vegan ~ "Vegan",
#                             makeable.veg ~ "Vegetarian",
#                             makeable.restrict ~ "Restricted",
#                             TRUE ~ "No restrictions"),
```


```{r}
## extend makeability


# MEAL %>% 
#   mutate(Ingredients = sprintj6(all_of(has), Ingredients, "green"))%>%
#     mutate(Ingredients = sprintj6(all_of(nh), Ingredients, "red"))%>%
#     mutate(Ingredients = sprintj6(all_of(subs1), Ingredients, "gold"))%>%
#     mutate(Ingredients = sprintj6(all_of(subs2), Ingredients, "orange"))%>%
#     mutate(Ingredients = gsub("xyz", " or ", gsub("><",">, <",gsub("&","", Ingredients))) )%>%
#   group_by(Meal) %>%
#   mutate(diet = case_when(is.vegan ~ "Vegan",
#                           is.veg& !is.vegan ~ "Vegetarian",
#                           TRUE ~ "Non-vegetarian"),
#          Needed = n.ingredients - p.ingredients) %>% 
#   select(recipe = Meal,  Source, Page,Type, Cuisine,diet, Ingredients, makeability, Needed) %>%
#   write.csv(., "jd_recipes.csv")


```


```{r}
# colorize.food <- function(column, color){
#   ifelse(column == "_", "_", sprintf("<span style='color: %s;'>%s</span>", color, 
#       column))
# }
#   
  # mutate_at(., c(not.has,has), nameify) %>% 
  # mutate(HAS = toString(c_across(all_of(has))),
  #        NOT.HAS = toString(c_across(all_of(not.has)))) %>% rowwise() %>% 
  # mutate(HAS = gsub("_","",gsub("_,","",HAS)),
  #        NOT.HAS = gsub("_","",gsub("_,","",NOT.HAS)))%>% 


# %>% filter(makeability %in% 1:3) 
# meals %>% group_by(Meal) %>% tally() %>% filter(n>1)

# names(RDF)
# names(MEAL)
# MEAL %>% 
#   mutate(diet = case_when(is.vegan ~ "Vegan",
#                           is.veg& !is.vegan ~ "Vegetarian",
#                           TRUE ~ "Non-vegetarian"),
#          Needed = n.ingredients - p.ingredients) %>% 
#   select(recipe = Meal,  Source, Page,Type, Cuisine,diet, Ingredients, makeability, NOT.HAS,Needed) %>%
#   write.csv(., "jd_recipes.csv")
# recipes_expand%>% 
#   mutate_at(., c(not.has,has), nameify) %>% 
#   mutate(HAS = toString(c_across(all_of(has))),
#          NOT.HAS = toString(c_across(all_of(not.has)))) %>% select(HAS)




# setdiff(ingredients$name, unique(c(nh, has, subs1, subs2)))
# length(unique(c(nh, has, subs1, subs2)))
# intersect(has, subs2)

# MEAL %>% 
#   mutate(across(all_of(has), ~colorize.food(.x, "green"))) %>%
#   mutate(across(all_of(subs1), ~colorize.food(.x, "gold"))) %>%
#   mutate(across(all_of(subs2), ~colorize.food(.x, "orange"))) %>%
#   mutate(across(all_of(nh), ~colorize.food(.x, "red"))) %>%
#   group_by(Meal) %>%
#   mutate(I = toString(c_across(all_of(c(has,nh, subs1, subs2)))) )%>% 
#   mutate(I = gsub("_","",gsub("_,","",I)))%>% select(1, I) %>%
#   datatable(., rownames = FALSE, escape = FALSE)
# 
# 
# ## Test out in app
# MEAL %>% 
#   mutate(across(all_of(has), ~colorize.food(.x, "green"))) %>%
#   mutate(across(all_of(subs1), ~colorize.food(.x, "gold"))) %>%
#   mutate(across(all_of(subs2), ~colorize.food(.x, "orange"))) %>%
#   mutate(across(all_of(nh), ~colorize.food(.x, "red"))) %>%
#   group_by(Meal) %>%
#   mutate(I = toString(c_across(all_of(c(has,nh, subs1, subs2)))) )%>% 
#   mutate(Ingredients = gsub("_","",gsub("_,","",I)))%>% 
#   mutate(diet = case_when(is.vegan ~ "Vegan",
#                           is.veg& !is.vegan ~ "Vegetarian",
#                           TRUE ~ "Non-vegetarian"),
#          Needed = n.ingredients - p.ingredients) %>% 
#   select(recipe = Meal,  Source, Page,Type, Cuisine,diet, Ingredients, makeability, NOT.HAS,Needed) %>%
#   write.csv(., "jd_recipes.csv")
# 
# 
# 
# ## The goal here was to colorize the raw ingredients list because i'm not accounting for the optional components of a recipe
# MEAL %>% select(1, feta, cilantro, Ingredients) %>% rowwise() %>%
#   mutate(Ingredients = gsub(feta,sprintf("<span style='color: %s;'>%s</span>", "green", feta), Ingredients))%>%
#   mutate(Ingredients = gsub(cilantro,sprintf("<span style='color: %s;'>%s</span>", "red", cilantro), Ingredients))%>%
#   datatable(., rownames = FALSE, escape = FALSE)
# 
# 
# MEAL %>% select(1, feta, cilantro, Ingredients) %>% rowwise() %>%
#   mutate(x = paste(feta, cilantro, sep = "|"),X = grepl(x, Ingredients)) 
# 
# sprintj2 <- function(vec, V, color){
#   len <- length(vec)
#   for(i in 1:length(vec)){
#   V[V %in% vec[i]] <- gsub(vec[i], sprintf("<span style='color: %s;'>%s</span>", color, vec[i]), V[V %in% vec[i]])
#   }
#   V
# }
# vec <- c( "butternut squash" ,"butter")
# V <- c("butternut squash","butter",  "beef")
# V[V %in% vec[1]]
# 
# sprintj2(all_of(vec), toString(c("butternut squash","butter",  "beef")), "red")  
# 
# sprintj(c("butter", "butternut squash"), c("butternut squash","butter",  "beef"), "red")  
# 
# sprintj3 <- function(vec, V, color){
#   len <- length(vec)
#   for(i in 1:length(vec)){
#   V <- gsub(paste0("[^>]",vec[i],"|^",vec[i] ), sprintf("<span style='color: %s;'> %s</span>", color, vec[i]), V)
#   }
#   V
# }
# sprintj3(all_of(vec), toString(c("butternut squash","butter",  "beef")), "red")  
# 
# sprintj(vec, c("butter","butternut squash",  "beef"), "red")  
# Vs <- toString(V)
# jj <- gsub(vec[1], sprintf(" <span style='color: %s;'>%s</span>", "red", vec[1]), Vs)
# 
# gsub(paste0(" ", vec[2]), sprintf("<span style='color: %s;'>%s</span>", "red", vec[2]), jj)
# gsub(paste0("[^>]", vec[2]), sprintf("<span style='color: %s;'>%s</span>", "red", vec[2]), jj)
# 
# sprintj <- function(vec, V, color){
#   len <- length(vec)
#   for(i in 1:length(vec)){
#   V <- gsub(vec[i], sprintf("<span style='color: %s;'>%s</span>", color, vec[i]), V)
#   }
#   V
# }
# 

#   MEAL %>% select(1, Ingredients) %>% rowwise() %>%
#   mutate(Ingredients = sprintj3(all_of(has), Ingredients, "green"))%>%
#     mutate(Ingredients = sprintj3(all_of(nh), Ingredients, "red"))%>%
#     mutate(Ingredients = sprintj3(all_of(subs1), Ingredients, "gold"))%>%
#     mutate(Ingredients = sprintj3(all_of(subs2), Ingredients, "orange"))%>%
#   datatable(., rownames = FALSE, escape = FALSE)
# 
# colorize.group <- function(x){
#   case_when(x %in% has ~ "green",
#             x %in% nh ~ "red",
#             x %in% subs1 ~ "gold",
#             x %in% subs2 ~ "orange")
# }
# 
# all.ing <- ingredients$name
# all.ing <- sort.vec(all.ing)
# 
# # sprintj4 <- function(vec, V){
# #   len <- length(vec)
# #   for(i in 1:length(vec)){
# #   V <- gsub(paste0("[^>]",vec[i],"|^",vec[i] ), sprintf("<span style='color: %s;'> %s</span>", colorize.group(vec[i]), vec[i]), V)
# #   }
# #   V
# # }
# # sprintj4(all_of(vec), toString(c("butternut squash","butter",  "beef")))  
# #   MEAL %>% select(1, Ingredients) %>% rowwise() %>%
# #   mutate(Ingredients = sprintj4(all_of(all.ing), Ingredients))%>%
# #   datatable(., rownames = FALSE, escape = FALSE)
# sprintj5 <- function(vec, V, color){
#   len <- length(vec)
#   
#   for(i in 1:length(vec)){
#     gg <- paste( paste0("^", vec[i]), paste0( vec[i], "$"), paste0("[,]", vec[i]), paste0(", ", vec[i]), paste0("or ", vec[i]), paste0(vec[i], " or"), sep = "|")
#   V <- gsub(gg, sprintf("<span style='color: %s;'> %s</span>,", color, vec[i]), V)
#   }
#   V
# }
# 
# sprintj5(all_of(vec), toString(c("butternut squash","butter",  "beef")), "red") 
# jjj <- sprintj5(all_of(vec[1]), toString(c("butternut squash","butter",  "beef")), "red") 
# i =2
# grep(paste0("^", vec[i]), jjj, v = TRUE)
# grep(paste0( vec[i], "$"), jjj, v = TRUE)
# grep(paste0("[,]", vec[i]), jjj, v = TRUE)
# grep(paste0("[, ]", vec[i]), jjj, v = TRUE)
# grep(paste0("[or ]", vec[i]), jjj, v = TRUE)
# grep(paste0(vec[i], "[ or]"),jjj, v = TRUE)
# 
# gsub(paste0("^", vec[i]), "xy", jjj)
# gsub(paste0( vec[i], "$"),"xy",  jjj)
# gsub(paste0("[,]", vec[i]),"xy",  jjj)
# gsub(paste0(", ", vec[i]),"xy",  jjj)
# gsub(paste0("or ", vec[i]), "xy", jjj)
# gsub(paste0(vec[i], " or"),"xy", jjj)
# gsub(paste0(vec[i], " ,"),"xy", jjj)
# gsub(paste0("[ ]",vec[i], "[,]"),"xy", jjj)
# 
# paste0("&",gsub(",","&",Vs), "&")


# sprintj6(all_of(vec), toString(c("butternut squash","butter",  "beef")), "red") 
# gsub("& | &","&", paste0("&",gsub(",","&&",toString(c("butternut squash","butter",  "beef"))), "&"))
# ## starts the string or starts with [,] or with [ or ]
# ## ends with [,] or [ or] or ends the string
# 
# paste(paste0("^", vec[1]), paste0( vec[1], "$"), paste0(",", vec[1]), paste0(", ", vec[1]), paste0("or ", vec[1]), paste0(vec[1], " or"), sep = "|")
# 
  MEAL %>% select(1, Ingredients) %>% rowwise() %>%
  mutate(Ingredients = sprintj6(all_of(has), Ingredients, "green"))%>%
    mutate(Ingredients = sprintj6(all_of(nh), Ingredients, "red"))%>%
    mutate(Ingredients = sprintj6(all_of(subs1), Ingredients, "gold"))%>%
    mutate(Ingredients = sprintj6(all_of(subs2), Ingredients, "orange"))%>%
    mutate(Ingredients = gsub("xyz", " or ", gsub("><",">, <",gsub("&","", Ingredients))) )%>%
  datatable(., rownames = FALSE, escape = FALSE)
  


  
  
  ## dried oregano
  ## mexican oregano
  ## blood orange
  ## 2 spaces before parmesan
  # MEAL %>% select(1, Ingredients) %>%.[1,2]
```


```{r}
M <- c("beef pie")
optional <- c("beef", "thyme")
exchange <- c("carrot", "onion", "garlic")
include <- c("kale", "milk", "cheddar", "brown rice")
# exchange <- c(NULL)


f.optional <- function(vec) {ifelse(length(vec)==0, "", paste0(str_c(vec, collapse = " or "), " or , "))}
f.exchange <- function(vec) {ifelse(length(vec)==0, "", gsub(" or [0-9]+ or", ",", paste0(str_c(vec, collapse = " or "), ", ")))}
f.include <- function(vec) {str_c(vec, collapse = ", ")}
paste.ingredients <- function(opt, exc, inc) paste0(f.optional(opt),f.exchange(exc), f.include(inc), collapse = "")
paste.ingredients(optional, exchange, include)

expand.grid(c(str_split(grep(" or ", str_split(s1, ", ")[[1]], v = TRUE, inv = F), " or "),
              item = list(grep(" or ", str_split(s1, ", ")[[1]], v = TRUE, inv = TRUE))))%>% 
  mutate(v =1, recipe = "meals$Meal[x]", VarXX = " ")%>%  unite(.,"variant", contains("Var"), remove = FALSE, sep = " ") %>% select(-VarXX)%>%
  pivot_longer(., c(-v, -recipe,-variant)) %>% unique() %>% select(-name) %>%filter(value != "") %>% 
  mutate(value = str_trim(value, "both"))%>%
  pivot_wider(., names_from = "value", values_from = "v")

exchange <- c("carrot", "onion", "garlic", "1", "oregano", "orange", "555", "carrot", "sausage")

gsub(" or [0-9]+ or", ",", paste0(str_c(exchange, collapse = " or "), ", "))
```


```{r}

# 
# recipes_expand %<>%
#   mutate(across(everything(), .fns = ~replace_na(.x, 0)))%>%
#   group_by(recipe, variant) %>%
#   mutate(rs = sum(c_across(where(is.numeric)))) %>%
#   select(1,2,rs, everything())
# ## Things that I can make right now
# recipes_expand %>% 
#   mutate(rs2 = sum(c_across(has)))%>% select(recipe, rs, rs2, everything()) %>% filter(rs2 >= rs) %>%
#   group_by(recipe) %>% summarise_all(., first)
# recipes_expand%>% mutate_at(., not.has, nameify) %>% 
#   mutate(NOT.HAS = toString(c_across(not.has))) %>% rowwise() %>% 
#   mutate(NOT.HAS = gsub("_","",gsub("_,","",NOT.HAS))) %>% select(1, NOT.HAS)
# 

# MEAL %>% filter(recipe == "black bean burgers") %>% select(1:11) %>% left_join(., bbb, by = "variant") %$% HAS[1]
# 
# bbbb <- Cs("american cheese", bacon, "hamburger buns", mayonnaise, ketchup, avocado, "jack cheese", "cheddar", "black bean burger" )
# 
# MEAL%>% filter(recipe == "test2") %>% select(1:6, "milk", "sour cream", "egg", "yogurt")
# 
# c("milk", "sour cream", "egg", "yogurt") %in% has
# ing$`black bean burgers`

# MEAL %>% filter(can.make==1) %>% group_by(recipe) %>% summarise_all(., first)
# 
# MEAL %>% group_by(can.make, can.make2, can.make3) %>% tally()
# 
# MEAL %>% mutate(makeability = 4 - sum(c_across(contains("can.make")))) %>% 
#   group_by(recipe) %>%
#   mutate(variants = n(), make1 = sum(makeability==1), make2 = sum(makeability==2), make3 = sum(makeability==3)) %>%
#   select(1, contains("make"), everything()) %>% arrange(recipe, makeability, desc(n.ingredients)) %>% slice(1) %>% filter(makeability %in% 1:3)


 # bbb%>% filter(recipe == "test2") %>% select(1:6, "milk", "sour cream", "egg", "yogurt")
```



```{r}


# mf3 <- function(x) {expand.grid(c(str_split(grep(" or ", ing[[x]], v = TRUE, inv = F), " or "),
#               item = list(grep(" or ", ing[[x]], v = TRUE, inv = TRUE))))%>% 
#   mutate(v =1, recipe = meals$Meal[x], VarXX = " ")%>%  unite(.,"variant", contains("Var"), remove = FALSE, sep = " ") %>% select(-VarXX)%>%
#   pivot_longer(., c(-v, -recipe,-variant)) %>% unique() %>% select(-name) %>%filter(value != "") %>% 
#   mutate(value = str_trim(value, "both"))%>%
#    mutate(has = ifelse(value %in% has, "has", "not")) %>% group_by(recipe, variant, has) %>% 
#   summarise(value = toString(value), does = n(), .groups = "keep") %>%
#   pivot_wider(., names_from = "has", values_from = c("value", "does")) }

rdf <- bind_rows(lapply(as.list(1:length(ing)), FUN = function(x) mf3(x)))%>%
    mutate(does_not = replace_na(does_not, 0)) 

rdf %>% group_by(recipe, does_not) %>% summarise_all(., first) %>% group_by(recipe) %>% filter(does_not == min(does_not)) %>% arrange(does_not) %>% select(recipe, does_not, value_not, value_has) %>% j.datatable(., nrow = 15)
```

```{r}
## add vegan/ veg classification
## Add back grouping data
mf4 <- function(x) {expand.grid(c(str_split(grep(" or ", ing[[x]], v = TRUE, inv = F), " or "),
              item = list(grep(" or ", ing[[x]], v = TRUE, inv = TRUE))))%>% 
  mutate(v =1, recipe = meals$Meal[x], VarXX = " ")%>%  unite(.,"variant", contains("Var"), remove = FALSE, sep = " ") %>% select(-VarXX)%>%
  pivot_longer(., c(-v, -recipe,-variant)) %>% unique() %>% select(-name) %>%filter(value != "") %>% 
  mutate(value = str_trim(value, "both"))%>%
  left_join(., ingredients %>% rename(value = name), by = "value" ) %>%
   mutate(has = ifelse(has ==1, "has", "not")) %>% 
  group_by(recipe, variant) %>% mutate(vegetarian = all(vegetarian==1), vegan = all(vegan ==1)) %>% 
  group_by(recipe, variant, has) %>% 
  summarise(value = toString(value), does = n(), diet = case_when(first(vegan)==TRUE ~ "Vegan",
                                                                  first(vegetarian)==TRUE ~ "Vegetarian",
                                                                  !first(vegan) & !first(vegetarian) ~"Non-vegetarian") , .groups = "keep") %>%
  pivot_wider(., names_from = "has", values_from = c("value", "does")) %>%
    left_join(., meals %>% select(recipe = Meal, Type, Cuisine, Source, Page), by = "recipe")}

rdf <- bind_rows(lapply(as.list(1:length(ing)), FUN = function(x) mf4(x)))%>%
    mutate(does_not = replace_na(does_not, 0)) 

rdf %>% group_by(recipe, does_not) %>% summarise_all(., first) %>% group_by(recipe) %>% filter(does_not == min(does_not)) %>% arrange(does_not) %>% select(recipe, does_not, value_not, value_has) %>% j.datatable(., nrow = 15)

RDF <- rdf %>% group_by(recipe, does_not) %>% summarise_all(., first) %>% group_by(recipe) %>% filter(does_not == min(does_not)) %>% arrange(does_not)

RDF %>% write.csv(., "jd_recipes.csv")



toMatch <- c("onion", "olive oil", "butter")
tooMatch <- c("zucchini", "asparagus")
andMatch <- function(string){
  string <- c(" ", string)
  gsub(" )", "^", paste(paste(string,collapse = ")(?=.*"), ")", sep = ""))
}

orMatch <- function(string) paste(string,collapse="|")
  
## Filters based on OR
RDF %>% filter(!grepl(orMatch(toMatch), value_has))
grepl(orMatch(tooMatch), value_has)
## Filters based on AND
RDF %>% filter(!grepl(andMatch(toMatch), value_has,perl=TRUE) )

'^(?=.*butter)(?=.*garlic)'
```


```{r}
## Substitue equivalent or semi-equivalent ingredients
somet <- ingredients %>% select(name, sometimes) %>%
   separate_rows(., sometimes, sep = ", ") %>%
  na.omit() %>% 
  left_join(., ingredients %>% select(sometimes = name, has3 = has)) %>% rename(value = name)

equi <- ingredients %>% select(name, equal) %>%
   separate_rows(., equal, sep = ", ") %>%
  na.omit() %>% 
  left_join(., ingredients %>% select(equal = name, has2 = has)) %>% rename(value = name)

makeable <- ingredients %>% select(name, makeable) %>%
  na.omit() %>% rename(value = name)

ingredients[ingredients$name == "tomato sauce", "has"] <- 0
# test = 230

X <- 120
mf5 <- function(X){
  expand.grid(c(str_split(grep(" or ", ing[[X]], v = TRUE, inv = F), " or "),
              item = list(grep(" or ", ing[[X]], v = TRUE, inv = TRUE))))%>% 
  mutate(v =1, recipe = meals$Meal[X], VarXX = " ")%>%  
  unite(.,"variant", contains("Var"), remove = FALSE, sep = " ") %>% 
  select(-VarXX)%>%
  pivot_longer(., c(-v, -recipe,-variant)) %>% 
  unique() %>% select(-name) %>%filter(value != "") %>% 
  mutate(value = str_trim(value, "both"))%>%
  left_join(., ingredients %>% rename(value = name) %>% select(-equal, -sometimes), by = "value" ) %>%
  arrange(variant) %>% 
  left_join(., equi, by = "value") %>% 
  left_join(., somet, by = "value") %>% 
  group_by(recipe, variant, value) %>% arrange(desc(has2), desc(has3)) %>%
  summarise_all(first) %>% 
  mutate(has2 = ifelse(is.na(has2), has, has2),
         has3 = ifelse(is.na(has3), has2, has3)) %>%
  mutate(HAS = case_when(has == 1 ~ "has",
                         has == 0 & has2 == 1 ~ "has2",
                         has ==0 & has2 %in% c(NA, 0) & has3 ==1 ~ "has3",
                         TRUE ~ "not"),
         value = case_when(HAS == "has2" ~ paste("(",value,")", sep = ""),
                           HAS == "has3" ~ paste("((",value,"))", sep = ""),
                           TRUE ~ value)) %>%
  group_by(recipe, variant) %>% 
  mutate(vegetarian = all(vegetarian==1), 
         vegan = all(vegan ==1),
         makeability = case_when(sum(has) == n() ~ 1,
                                 sum(has2) == n() ~ 2,
                                 sum(has3) == n() ~ 3,
                                 TRUE ~ 5)) %>% 
  group_by(recipe, variant, HAS,makeability) %>% 
  summarise(value = toString(value), does = n(), 
            diet = case_when(first(vegan)==TRUE ~ "Vegan", 
                             first(vegetarian)==TRUE ~ "Vegetarian", 
                             !first(vegan) & !first(vegetarian) ~"Non-vegetarian"), .groups = "keep") %>%
  pivot_wider(., names_from = "HAS", values_from = c("value", "does") ) %>%
    left_join(., meals %>% select(recipe = Meal, Type, Cuisine, Source, Page), by = "recipe") %>%
   mutate(does = sum(c_across(contains("does_has")))) %>% 
  unite(., "value", contains("value_has"), sep = ", ") %>% # Need to fix this here
  select(-contains("does_has"), -contains("value_has")) %>%
  ungroup() %>%
         mutate(variants = n(), mv = sum(makeability != 5)) %>% arrange(makeability, desc(does)) # %>% slice(1)
}
mf5(51) ## Why is NA in list of ingredients?
rdx <- bind_rows(lapply(as.list(1:length(ing)), FUN = function(x) mf5(x)))%>%
    mutate(does_not = replace_na(does_not, 0)) 

rdx %>% arrange(recipe, makeability, desc(does), does_not) %>% group_by(recipe) %>% slice(1) %>% group_by(makeability) %>% tally()


meals[40,] %>%
   separate_rows(., Ingredients, sep = ", ") %>% 
  mutate(variants = prod(1 + str_count(Ingredients, " or " )) )%>%
  group_by(Meal) %>%
  mutate(or = grepl(" or ", Ingredients), OR = cumsum(or)*or)%>%
   separate_rows(., Ingredients, sep = " or ") %>%
  left_join(., ingredients %>% select(Ingredients = name, has) %>% bind_rows(. ,data.frame(Ingredients = "", has = 1))) 


```



```{r}
create.fluid.row <- function(DAT){

        foo <- ingredients %>% group_by(class, class2) %>% tally() %>% group_by(class) %>% tally()
        n.dairy <- foo %>% filter(class=="dairy") %$% n
        n.meat <- foo %>% filter(class=="meat") %$% n
        n.prod <- foo %>% filter(class=="produce") %$% n
        n.pant <- foo %>% filter(class=="pantry") %$% n
        n.spice <- foo %>% filter(class=="spice") %$% n
  
  BAR.d <- NULL
  for(i in 1:n.dairy){
    bar <- paste("                 checkboxGroupInput('dairy",i,"', names(Da)[",i,"], Da[[",i,"]]$name, selected = Dah[[",i,"]]$name)",
                 ifelse(i == n.dairy,")," , ",\n"), sep = "")
    BAR.d <- paste(BAR.d, bar, sep = "") }
  
  BAR.m <- NULL
  for(i in 1:n.meat){
    bar <- paste("                 checkboxGroupInput('meat",i,"', names(Me)[",i,"], Me[[",i,"]]$name, selected = Meh[[",i,"]]$name)",
                 ifelse(i == n.meat,")," , ",\n"), sep = "")
    BAR.m <- paste(BAR.m, bar, sep = "")}
  
  BAR.pr <- NULL
  for(i in 1:n.prod){
    bar <- paste("                 checkboxGroupInput('produce",i,"', names(Pr)[",i,"], Pr[[",i,"]]$name, selected = Prh[[",i,"]]$name)",
                 ifelse(i == n.prod,")," , ",\n"), sep = "")
    BAR.pr <- paste(BAR.pr, bar, sep = "")}
  
  BAR.pa <- NULL
  for(i in 1:n.pant){
    bar <- paste("                 checkboxGroupInput('pantry",i,"', names(Pa)[",i,"], Pa[[",i,"]]$name, selected = Pah[[",i,"]]$name)",
                 ifelse(i == n.pant,")," , ",\n"), sep = "")
    BAR.pa <- paste(BAR.pa, bar, sep = "")}
  
  BAR.s <- NULL
  for(i in 1:n.spice){
    bar <- paste("                 checkboxGroupInput('spice",i,"', names(Sp)[",i,"], Sp[[",i,"]]$name, selected = Sph[[",i,"]]$name)",
                 ifelse(i == n.spice,")," , ",\n"), sep = "")
    BAR.s <- paste(BAR.s, bar, sep = "")}
  
  cat(paste("column(2, 'Dairy',\n", BAR.d, 
            "\ncolumn(2, 'Meat',\n", BAR.m,
            "\ncolumn(2, 'Produce',\n", BAR.pr,
            "\ncolumn(2, 'Pantry',\n", BAR.pa,
            "\ncolumn(2, 'Spice',\n", BAR.s,
            sep = ""))}

create.fluid.row(ingredients)


food.df <- function(DAT){
  foo <- ingredients %>% group_by(class, class2) %>% tally() %>% group_by(class) %>% tally()
BAR <- NULL
for(i in 1:5){
  
bar <- paste("data.frame(Food = ", foo$class[i],"$name) %>% group_by(Food) %>% mutate(Has = 1*(Food %in% c(", 
             toString(paste("input$",foo$class[i], 1:foo$n[i], sep = "")),")))", ifelse(i == nrow(foo), "", ","), sep = "")

BAR <- paste(BAR, bar, sep = "\n")

bar.bar <- paste("bind_rows(",BAR, ")", sep = "")
}

cat(bar.bar)
}

food.df(ingredients)
```


```{r}
recipes_expand%>%ungroup() %>% select(4:100) %>% slice(1:25) %>% as.matrix() %>% cor() %>% qgraph()

library("qgraph")
data(big5)
data(big5groups)
qgraph(cor(big5),minimum=0.25,cut=0.4,vsize=2,legend=TRUE,borders=FALSE)
title("Big 5 correlations",line=-2,cex.main=2)
```


```{r}
## dead

# ING <- unlist(ing) %>% as.data.frame() %>% rownames_to_column() %>% 
#   select(meal = rowname, ing = ".") %>% 
#   mutate(meal = gsub('[[:digit:]]+', '', meal)) %>% 
#   mutate(or = 0.9*grepl(" or ", ing)) %>%
#   separate_rows(., ing, sep = " or ") %>% 
#   mutate(v = 1-or) %>% select(-or) %>% 
#   group_by(meal) %>% mutate(n.or = sum(v!=1)) %>% 
#   pivot_wider(., names_from= "ing", values_from = "v") %>%
#   mutate(across(everything(), .fns = ~replace_na(.x, 0))) %>% 
#   group_by(meal) %>%
#   mutate(rs = sum(c_across(where(is.numeric))))

# ING %>% #select(1, has, rs)%>%
#   mutate(rs2 = sum(c_across(has))) %>% filter(rs2 >= rs) %>% select(meal, rs, rs2, everything())
# 
# ING %>% select(-rs) %>% pivot_longer(., -meal) %>% filter(value > 0) %>% group_by(name) %>% tally() %>% arrange(desc(n))
# 
# ## rs needs to capture the `or` and not count them all
# ## how to handle multiple "or" recipes (a or b, c or d)
# ## could repeat recipes and iterate through the combinations?
# 
# ## need to figure out how to handle optional ingredients
# ## Same fix as above?
# 
# ing$`peanut noodles with shrimp` %in% "(optional)" 
# ing[grepl("(optional)", ing)]
# 
# str_split(ing$`beef with broccoli`, " or ") %>% as.data.frame()%>%t() 
# 
# expand.grid(expand.grid(str_split(grep(" or ", ing$`beef with broccoli`, v = TRUE), " or ")) %>% 
#   mutate(recipe = paste("recipe (", Var1, Var2,")"))%>% 
#   pivot_longer(., -recipe),
# expand.grid(grep(" or ", ing$`beef with broccoli`, v = TRUE, inv = TRUE)))   %>% mutate(v = 1) %>% unique() %>% select(-name) %>%
#   pivot_wider(., names_from = c("value"), values_from = "v")
# 
# 
# expand.grid(expand.grid(str_split(grep(" or ", ing$`ma po tofu`, v = TRUE), " or ")) %>% unlist(),
# grep(" or ", ing$`ma po tofu`, v = TRUE, inv = TRUE)) %>% mutate(recipe = paste("recipe (", Var1,")")) %>% 
#   pivot_longer(., -recipe) %>% mutate(v = 1) %>% unique() %>% select(-name) %>%
#   pivot_wider(., names_from = c("value"), values_from = "v")
# 
# expand.grid(c("a", "b"), c("c", "d"), d = expand.grid(grep(" or ", ing$`beef with broccoli`, v = TRUE, inv = TRUE))$Var1) %>% 
#   mutate(v =1, nameth = paste(Var1, Var2))%>% 
#   pivot_longer(., c(-v, -nameth)) %>% unique() %>% select(-name) %>%
#   pivot_wider(., names_from = "value", values_from = "v")
# 
# expand.grid(c(str_split(grep(" or", ing[[26]], v = TRUE, inv = F), " or"), 
#               item = list(grep(" or", ing[[26]], v = TRUE, inv = TRUE)))) %>% 
#   mutate(v =1, recipe = "recipe", VarXX = " ") %>%  unite(.,"variant", contains("Var"), remove = FALSE) %>% select(-VarXX) %>%
#   pivot_longer(., c(-v, -recipe, -variant)) %>% unique() %>% select(-name) %>%
#   pivot_wider(., names_from = "value", values_from = "v")
```

